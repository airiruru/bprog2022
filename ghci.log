GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-05-19 15:51:02.396344559
>>> 23+5
28
2022-05-19 15:54:05.021852232
>>> 3+2*5
13
2022-05-19 15:54:46.267138184
>>> ５－４－８

<interactive>:3:1: error: lexical error at character '\65301'
2022-05-19 15:55:34.365614825
>>> 5-4-8
-7
2022-05-19 15:56:15.033880831
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:36.074322856
>>> double 3

<interactive>:6:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:01.130819772
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-05-26 15:02:10.564346078
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:03:40.395876165
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:07.121857176
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:32.350636279
>>> :e src/First.hs
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
Ok, no modules loaded.
2022-05-26 15:49:05.365067949
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:05.432628548
>>> double 3
6
2022-05-26 15:56:17.638454464
>>> double 123
246
2022-05-26 15:56:26.508689954
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-06-09 14:55:12.813874413
>>> 2 + 3 * 4
14
2022-06-09 14:58:29.872138735
>>> (2 + 3)*4
20
2022-06-09 15:00:19.083104153
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:41.315695385
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:05:09.196208533
>>> sqrt (25 :: Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:11.706994874
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:34.573539699
>>> sqrt 25
5.0
2022-06-09 15:09:55.942383998
>>> hoge 25 :: Int

<interactive>:8:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:18.819338013
>>> head [1, 2, 3]
1
2022-06-09 15:46:17.139226555
>>> head[3, 1, 4, 1, 5]
3
2022-06-09 15:46:40.222152092
>>> head[]
*** Exception: Prelude.head: empty list
2022-06-09 15:48:23.436564339
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:50:40.461429757
>>> hoge
[3,1,4,1,5]
2022-06-09 15:50:51.415538114
>>> head hoge
3
2022-06-09 15:51:18.537730781
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:25.786278626
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:31.830364555
>>> hoge !! 0
3
2022-06-09 15:55:00.641738711
>>> hoge !! 2 hoge

<interactive>:18:9: error:
    • No instance for (Num ([Int] -> Int)) arising from the literal ‘2’
        (maybe you haven't applied a function to enough arguments?)
    • In the expression: 2
      In the second argument of ‘(!!)’, namely ‘2 hoge’
      In the expression: hoge !! 2 hoge
2022-06-09 15:55:29.279708442
>>> hoge !! 2
4
2022-06-09 15:55:40.73201761
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:27.619156147
>>> hoge
[3,1,4,1,5]
2022-06-09 15:56:58.808198871
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:15.689601061
>>> hoge 5 hoge

<interactive>:23:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:23:1)
2022-06-09 15:58:17.998375176
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:49.46773618
>>> take 10

<interactive>:25:1: error:
    • No instance for (Show ([a0] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-09 15:59:07.835335647
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:25.574993337
>>> drop 10 hoge
[]
2022-06-09 15:59:44.366244469
>>> length hoge
5
2022-06-09 16:01:01.216415586
>>> length []
0
2022-06-09 16:01:16.620737084
>>> sam hoge

<interactive>:30:1: error:
    • Variable not in scope: sam :: [Int] -> t
    • Perhaps you meant ‘sum’ (imported from Prelude)
2022-06-09 16:01:57.565086605
>>> sum hoge
14
2022-06-09 16:02:15.215298307
>>> product hoge
60
2022-06-09 16:02:30.274748191
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:40.904285116
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:26.3799221
>>> :e src/First.hs
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
Ok, no modules loaded.
2022-06-09 16:07:37.289043687
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:07:37.354054789
>>> double 3 + 3
9
2022-06-09 16:08:00.813599819
>>> double (3 + 3)
12
2022-06-09 16:11:09.116644839
>>> 
2022-06-09 16:11:17.583992091
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-06-16 15:02:18.251187554
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:11.993994282
>>> :e src/First.hs
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:47.471153682
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:47.533332906
>>> 
2022-06-16 15:11:36.616337732
>>> double

<interactive>:5:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:12:57.406339211
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:06.188303805
>>> 
2022-06-16 15:19:59.313947838
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:09.784102349
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:21:01.376981891
>>> factorial 3
6
2022-06-16 15:22:06.632714179
>>> factorial 4
24
2022-06-16 15:22:22.207154786
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: Int -> Int
  13      average xs = sum xs `div` length xs
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:22: error:
    • Couldn't match expected type ‘t0 Int’ with actual type ‘Int’
    • In the first argument of ‘sum’, namely ‘xs’
      In the first argument of ‘div’, namely ‘sum xs’
      In the expression: sum xs `div` length xs
   |
13 |     average xs = sum xs `div` length xs
   |                      ^^

src/First.hs:13:38: error:
    • Couldn't match expected type ‘t1 a0’ with actual type ‘Int’
    • In the first argument of ‘length’, namely ‘xs’
      In the second argument of ‘div’, namely ‘length xs’
      In the expression: sum xs `div` length xs
   |
13 |     average xs = sum xs `div` length xs
   |                                      ^^
Failed, no modules loaded.
2022-06-16 15:37:18.504982493
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:38:03.719913554
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:39:26.491822575
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:49:51.829271026
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:00.157991579
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : init xs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:28.144077646
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:14:41.088455682
>>> myinit []
*** Exception: src/First.hs:(19,5)-(20,30): Non-exhaustive patterns in function myinit

2022-06-16 16:14:56.250198916
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 12:03:00.187431647
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 12:32:47.565946489
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 12:33:39.563443382
>>> :t Num

<interactive>:1:1: error:
    • Data constructor not in scope: Num
    • Perhaps you meant variable ‘sum’ (imported from Prelude)
2022-07-04 12:34:00.869942646
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-07-04 12:34:24.539291334
>>> 1>=2
False
2022-07-04 12:36:28.616779604
>>> 'a' <'B'
False
2022-07-04 12:37:08.714855027
>>> '' < 'a'

<interactive>:5:1: error:
    Parser error on `''`
    Character literals may not be empty
2022-07-04 12:37:45.463223588
>>> 'ab' < 'b'

<interactive>:6:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-07-04 12:38:20.093557207
>>> 1 /= 1
False
2022-07-04 12:38:54.545210136
>>> 1 /=2
True
2022-07-04 12:39:12.048197526
>>> :Info abs
unknown command ':Info'
use :? for help.
2022-07-04 12:41:11.041355131
>>> abs

<interactive>:10:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-04 12:41:39.801711488
>>> abs (-234)
234
2022-07-04 12:42:44.439477214
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 12:47:05.97921735
>>> [ x^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-07-04 12:49:24.655716645
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-07-04 12:50:05.874296252
>>> [ x:2 | x <- [1..5]]]

<interactive>:3:21: error: parse error on input ‘]’
2022-07-04 12:51:27.42991923
>>> [ x:2 | x <- [1..5]]

<interactive>:4:1: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall {a}. (Enum a, Num a, Num [a]) => [[a]]
2022-07-04 12:51:42.579618684
>>> [ x * 2 | x <- [1 . . 5]]

<interactive>:5:21: error: parse error on input ‘.’
2022-07-04 12:52:37.307064715
>>> [ x 'div' 2 |x <- [1 .. 5]]

<interactive>:6:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-07-04 12:53:27.374609842
>>> [ x 'div' 2 | x <- [1 .. 5]]

<interactive>:7:5: error:
    • Syntax error on 'div'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'div'
2022-07-04 12:54:21.122430534
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 12:55:57.115593161
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 16:02:34.380344363
>>> [ x ^ 2 | x <- [1 .. 5]

<interactive>:1:24: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-04 16:04:13.74821904
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-07-04 16:04:57.993276966
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 16:07:41.113689301
>>> [ x ^ 2 | x <- [ 1 .. 5] ]
[1,4,9,16,25]
2022-07-04 16:12:51.156596619
>>> map (^2) [1 .. 5]
[1,4,9,16,25]
2022-07-04 16:13:51.826186677
>>> [ x * 2 | x <- [1 .. 5]

<interactive>:3:24: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-04 16:14:54.812507873
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-07-04 16:15:09.18031052
>>> [ x `div` 2|x <- [1 .. 5] ]
[0,1,1,2,2]
2022-07-04 16:16:58.772945241
>>> [ (x , y) |x <- "abc" , y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-07-04 16:20:36.937811349
>>> [ x, y) |y <- [4,5], x ,- "abc" ]

<interactive>:7:7: error: parse error on input ‘)’
2022-07-04 16:21:52.075254181
>>> [ x, y) |y <- [4,5], x<-,- "abc" ]

<interactive>:8:7: error: parse error on input ‘)’
2022-07-04 16:22:30.46306644
>>> [ x, y) |y <- [4,5], x <- "abc" ]

<interactive>:9:7: error: parse error on input ‘)’
2022-07-04 16:22:48.288739451
>>> [ (x, y) |y <- [4,5], x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-07-04 16:23:09.688289707
>>> :e
No files to edit.
2022-07-04 16:29:21.393276353
>>> :l
Ok, no modules loaded.
2022-07-04 16:29:21.501111967
>>> :e src/First.hs
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : init xs
Ok, no modules loaded.
2022-07-04 16:30:08.970651711
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-07-04 16:30:09.040261852
>>> myconcat [[1,2,3],[4,5],[6.7.8.9]]

<interactive>:15:1: error:
    • Variable not in scope: myconcat :: [[a0 -> c0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-07-04 16:32:57.850973107
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:16:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-07-04 16:34:17.950715338
>>> [ 1 | _<- [1 ..5] ]
[1,1,1,1,1]
2022-07-04 16:37:53.655095845
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : init xs
Ok, one module loaded.
2022-07-04 16:41:59.414591157
>>> mylength ['a' .. 'z']

<interactive>:19:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:42:58.951478406
>>> mylength ['a' .. 'z' ]

<interactive>:20:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:43:52.609046385
>>> mylength ['a' .. 'z' ]

<interactive>:21:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:45:12.961931425
>>> mylength ['a' .. 'z' ]

<interactive>:22:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:46:04.625969195
>>> mylength ['a' .. 'z' ]

<interactive>:23:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:47:10.342585886
>>> mylength ['a' .. 'z' ]

<interactive>:24:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:48:05.971167916
>>> mylength ['a' .. 'z' ]

<interactive>:25:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 16:49:09.830986465
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : init xs
Ok, one module loaded.
2022-07-04 16:49:14.753806471
>>> : r
catn: r: openFile: does not exist (No such file or directory)
2022-07-04 16:49:34.167145025
>>> 
2022-07-04 16:53:03.003890724
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : (init xs)
  21  
  22      myconcat :: [[a]]-> [a]
  23      myconcat xss = [ x | xs <- xss, x<- xs]
  24  
  25      mylength :: [a] -> Int
  26      mylength xs = sum [ 1 | _<- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-07-04 16:53:06.506087837
>>> mylength ['a' .. 'z' ]
26
2022-07-04 16:53:17.653409394
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-07-04 16:55:05.007029145
>>> ['あ' | 'ん']

<interactive>:32:8: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Char’
    • In the expression: 'ん'
      In a stmt of a list comprehension: 'ん'
      In the expression: ['あ' | 'ん']
2022-07-04 16:57:21.968709627
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 16:59:33.300580784
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-07-04 17:01:11.603046911
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-07-04 17:01:43.595197371
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 17:43:46.431398959
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-07-04 17:44:37.770811245
>>> map (^2) [1 .. 5]
[1,4,9,16,25]
2022-07-04 17:45:16.626859407
>>> [ x * 2 | x <- [ 1 .. 5]]
[2,4,6,8,10]
2022-07-04 17:46:13.597197037
>>> [ x `div` 2 | x < [1 .. 5 ] ]

<interactive>:4:3: error: Variable not in scope: x

<interactive>:4:15: error: Variable not in scope: x :: [a0]
2022-07-04 17:46:57.13819284
>>> [ x `div` 2 | x <- [1 .. 5] ]
[0,1,1,2,2]
2022-07-04 17:47:44.016547148
>>> [ x `divMod` 2 | x <- [1 .. 5] ]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-07-04 17:48:58.776564433
>>> [ (x,y) |y <- [4, 5], x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-07-04 17:50:42.269686208
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-04 17:52:18.559252808
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-07-04 17:54:05.03668699
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-07-04 17:54:48.222210082
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-07-04 17:55:56.516247843
>>> [ x `div` 2 | x < [1 .. 5] ]

<interactive>:4:3: error: Variable not in scope: x

<interactive>:4:15: error: Variable not in scope: x :: [a0]
2022-07-04 17:56:40.205910823
>>> [ x `divMod` 2 | x < [1 .. 5] ]

<interactive>:5:3: error: Variable not in scope: x

<interactive>:5:18: error: Variable not in scope: x :: [a0]
2022-07-04 17:57:37.057874495
>>> [ x `divMod` 2 | x <- [1 .. 5] ]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-07-04 17:58:32.217958946
>>> [ (x ,y) | x <- "abc" ,y <- [4,5]

<interactive>:7:34: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-04 17:59:52.616607007
>>> [ (x ,y) | x <- "abc" ,y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-07-04 18:01:00.085560489
>>> [ (x,y) | y <- [4,5], <- "abc"

<interactive>:9:23: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
2022-07-04 18:02:59.038762634
>>> [ (x,y) | y <- [4,5], <- "abc"]

<interactive>:10:23: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
2022-07-04 18:03:09.270530768
>>> [ (x,y) | y <- [4,5],x  <- "abc"]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-07-04 18:03:37.838069088
>>> l src/

<interactive>:12:7: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-07-04 18:06:30.29249258
>>> l src/First.hs

<interactive>:13:7: error:
    Not in scope: ‘First.hs’
    No module named ‘First’ is imported.
2022-07-04 18:07:19.034221782
>>> :e src/First.hs
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : (init xs)
  21  
  22      myconcat :: [[a]] -> [a]
  23      myconcat xss = [x |xs <- xss, x <- xs]
Ok, no modules loaded.
2022-07-04 18:07:54.99265847
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-07-04 18:07:55.097744574
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-07-04 18:08:54.910119115
>>> [ 1| _<- [1 .. 5] ]
[1,1,1,1,1]
2022-07-04 18:10:14.054915725
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : (init xs)
  21  
  22      myconcat :: [[a]] -> [a]
  23      myconcat xss = [x |xs <- xss, x <- xs]
  24  
  25      mylength :: [a] -> Int
  26      mylength xs = [ 1 | _<-xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:26:19: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[a0]’
    • In the expression: [1 | _ <- xs]
      In an equation for ‘mylength’: mylength xs = [1 | _ <- xs]
   |
26 |     mylength xs = [ 1 | _<-xs]
   |                   ^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-04 18:12:04.436082598
>>> mylength ['a' .. 'z']

<interactive>:19:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 18:13:15.532716625
>>> mylength ['a' .. 'z']

<interactive>:20:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 18:14:25.352854236
>>> mylength ['a' .. 'z']

<interactive>:21:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-07-04 18:15:20.233067418
>>> :e
   1  module　First　where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial :: Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15      ave :: [Int] -> Int
  16      ave xs = div (sum xs) (length xs)
  17  
  18      myinit :: [a] -> [a]
  19      myinit (x:[]) = []
  20      myinit (x:xs) =x : (init xs)
  21  
  22      myconcat :: [[a]] -> [a]
  23      myconcat xss = [x |xs <- xss, x <- xs]
  24  
  25      mylength :: [a] -> Int
  26      mylength xs = sum [ 1 | _<- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-07-04 18:15:53.014393189
>>> mylength ['a' .. 'z']
26
2022-07-04 18:15:57.222201938
>>> ['あ' | 'ん']

<interactive>:24:8: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Char’
    • In the expression: 'ん'
      In a stmt of a list comprehension: 'ん'
      In the expression: ['あ' | 'ん']
2022-07-04 18:17:45.135868383
>>> 
2022-07-04 18:21:15.040733941
>>> 
2022-07-04 18:26:50.106398464
>>> ['あ' | 'ん']

<interactive>:27:8: error:
    • Couldn't match expected type ‘Bool’ with actual type ‘Char’
    • In the expression: 'ん'
      In a stmt of a list comprehension: 'ん'
      In the expression: ['あ' | 'ん']
2022-07-04 18:28:19.9340937
>>> putStrln  it

<interactive>:28:1: error:
    • Variable not in scope: putStrln :: Int -> t
    • Perhaps you meant one of these:
        ‘putStrLn’ (imported from Prelude),
        ‘putStr’ (imported from Prelude)
2022-07-04 18:32:45.218868548
>>> [ 'あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-07-04 18:35:28.381202129
>>> putStrln  it

<interactive>:30:1: error:
    • Variable not in scope: putStrln :: [Char] -> t
    • Perhaps you meant one of these:
        ‘putStrLn’ (imported from Prelude),
        ‘putStr’ (imported from Prelude)
2022-07-04 18:35:33.292850272
>>> putStrln  it

<interactive>:31:1: error:
    • Variable not in scope: putStrln :: [Char] -> t
    • Perhaps you meant one of these:
        ‘putStrLn’ (imported from Prelude),
        ‘putStr’ (imported from Prelude)
2022-07-04 18:37:05.815589344
>>> putSutLn it

<interactive>:32:1: error:
    • Variable not in scope: putSutLn :: [Char] -> t
    • Perhaps you meant ‘putStrLn’ (imported from Prelude)
2022-07-04 18:37:19.411550123
>>> 
2022-07-04 18:37:46.926680292
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-07-04 18:38:07.563226561
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-07 16:05:00.160719294
>>> :e src/Caesar.hs
   1  module Caesal where
   2  
   3  import Date.Char
Ok, no modules loaded.
2022-07-07 16:05:33.279228727
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesal           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-07 16:05:33.350318911
>>> ord 'A'

<interactive>:3:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 16:05:58.918729873
>>> ord 'A'

<interactive>:4:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 16:07:48.318740211
>>> ord 'A'

<interactive>:5:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 16:10:52.816318781
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-07 20:22:50.59458737
>>> 
2022-07-07 20:22:58.248081206
>>> :e src Caesar.hs
catn: src: openFile: inappropriate type (is a directory)
2022-07-07 20:23:22.548821837
>>> :l src Caesar.hs
target ‘src’ is not a module name or a source file
2022-07-07 20:23:22.613370842
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-07 20:24:34.087342418
>>> :e src/Caesal.hs
catn: src/Caesal.hs: openFile: does not exist (No such file or directory)
2022-07-07 20:24:53.149811398
>>> :l src/Caesal.hs

<no location info>: error: can't find file: src/Caesal.hs
Failed, no modules loaded.
2022-07-07 20:24:53.255101281
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-07 20:28:44.395893537
>>> :e src/caesar.hs
catn: src/caesar.hs: openFile: does not exist (No such file or directory)
2022-07-07 20:29:05.617400351
>>> :l src/caesar.hs

<no location info>: error: can't find file: src/caesar.hs
Failed, no modules loaded.
2022-07-07 20:29:05.7155852
>>> :e src/Caesar.hs
   1  module Caesal where
   2  
   3  import Date.Char

<no location info>: error: can't find file: src/caesar.hs
Failed, no modules loaded.
2022-07-07 20:29:48.909124477
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesal           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-07 20:29:49.009428228
>>> ord 'A'

<interactive>:5:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 20:30:13.914030952
>>> 
2022-07-07 20:33:43.486119789
>>> ord 'A'

<interactive>:7:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 20:33:55.361427808
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Date.Char
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-07 20:34:53.442186327
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-07 20:34:53.537129592
>>> ord 'A'

<interactive>:10:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 20:35:03.516917593
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 20:36:00.353373154
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 20:36:00.441874201
>>> ord 'A'
65
2022-07-07 20:36:12.673558952
>>> ord 'a'
97
2022-07-07 20:36:25.237326075
>>> ::q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-14 18:03:01.464254193
>>> :e src/Caesar where
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-14 18:03:49.687287988
>>> :l src/Caesar where
target ‘where’ is not a module name or a source file
2022-07-14 18:03:49.765283464
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
Ok, no modules loaded.
2022-07-14 18:04:20.876734772
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:04:20.971050702
>>> let2int 'a'

<interactive>:5:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 18:05:43.217037376
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-14 18:07:48.691947453
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
Ok, no modules loaded.
2022-07-14 18:08:11.054421055
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:08:11.15773536
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:08:57.09601612
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:08:57.194020813
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:09:58.93149111
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:09:59.030439251
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-14 18:10:36.438667339
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
Ok, no modules loaded.
2022-07-14 18:11:16.656368633
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:11:16.760788967
>>> let2int 'a'

<interactive>:3:1: error:
    Variable not in scope: let2int :: Char -> t
2022-07-14 18:12:07.982912784
>>> let2Int 'a'

<interactive>:4:1: error:
    Variable not in scope: let2Int :: Char -> t
2022-07-14 18:12:48.942063312
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/airi/bprog2022/.ghci
2022-07-14 18:13:27.129901353
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int :: c = ord c
Ok, no modules loaded.
2022-07-14 18:13:48.483544802
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:6:1: error:
    • You cannot bind scoped type variable ‘c’
        in a pattern binding signature
    • In the pattern: let2int :: c
      In a pattern binding: let2int :: c = ord c
  |
6 | let2int :: c = ord c
  | ^^^^^^^^^^^^

src/Caesar.hs:6:20: error: Variable not in scope: c :: Char
  |
6 | let2int :: c = ord c
  |                    ^
Failed, no modules loaded.
2022-07-14 18:13:48.587312975
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 18:15:35.618034679
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 18:15:35.717609915
>>> let2int 'a'
97
2022-07-14 18:15:48.328736168
>>> let2int 'z'
122
2022-07-14 18:17:47.073857904
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 18:19:40.588022473
>>> let2int 'a'
0
2022-07-14 18:19:59.930936582
>>> let2int 'z'
25
2022-07-14 18:20:11.592542094
>>> ord 'a'
97
2022-07-14 18:22:22.025101584
>>> chr 97
'a'
2022-07-14 18:22:42.036536524
>>> int2let 0

<interactive>:12:1: error:
    Variable not in scope: int2let :: t0 -> t
2022-07-14 18:24:20.352234483
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 18:24:44.044891308
>>> int2let 0
'a'
2022-07-14 18:24:54.393966834
>>> int2let 25 
'z'
2022-07-14 18:25:11.565724614
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (i + ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15      
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) `mod` 26)
   |     ^
Failed, no modules loaded.
2022-07-14 18:31:54.796421149
>>> ::r
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) `mod` 26)
   |     ^
Failed, no modules loaded.
2022-07-14 18:34:31.540869735
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (i + ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15      
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) `mod` 26)
   |     ^
Failed, no modules loaded.
2022-07-14 18:35:26.685939123
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (i + ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13     ¦ isLower c = int2let ((let2int c + n) `mod` 26)
  14     ¦ otherwise = c 
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:4: error: parse error on input ‘¦’
   |
13 |    ¦ isLower c = int2let ((let2int c + n) `mod` 26)
   |    ^
Failed, no modules loaded.
2022-07-14 18:41:08.140909394
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (i + ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13     isLower c = int2let ((let2int c + n) `mod` 26)
  14     otherwise = c 
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:14: error: parse error on input ‘=’
   |
13 |    isLower c = int2let ((let2int c + n) `mod` 26)
   |              ^
Failed, no modules loaded.
2022-07-14 18:41:33.053383793
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (i + ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:9:18: error: Variable not in scope: i :: Int
  |
9 | int2let n = chr (i + ord 'a' + n)
  |                  ^
Failed, no modules loaded.
2022-07-14 18:43:06.783960925
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 18:43:49.989960782
>>> shift 3 'a'
'd'
2022-07-14 18:44:15.518512264
>>> shift (-3) 'd'
'a'
2022-07-14 18:44:35.00494136
>>> shift 3 'z'
'c'
2022-07-14 18:45:06.810518437
>>> shift 3 ' '
' '
2022-07-14 18:46:04.691911589
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [ shift n x | x <- xs ]
   |               ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 18:49:59.708444325
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [ shift n x | x <- xs ]
   |               ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 18:56:21.430764624
>>> 
2022-07-14 19:00:50.938271242
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [ shift n x | x <- xs ]
   |               ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 19:00:53.945064974
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [shift n x | x <- xs]
   |               ^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 19:05:39.684727813
>>> 
2022-07-14 19:05:42.161938959
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [shift nx | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:22: error:
    • Variable not in scope: nx :: Int
    • Perhaps you meant one of these: ‘x’ (line 17), ‘n’ (line 17)
   |
17 | encode n xs = [shift nx | x <- xs]
   |                      ^^
Failed, no modules loaded.
2022-07-14 19:05:57.051057108
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [ shift n x | x <- xs ]
   |               ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 19:06:40.687644267
>>> 
2022-07-14 19:08:21.42329777
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:15: error:
    • Couldn't match expected type ‘string’ with actual type ‘[Char]’
      ‘string’ is a rigid type variable bound by
        the type signature for:
          encode :: forall string. Int -> string -> string
        at src/Caesar.hs:16:1-35
    • In the expression: [shift n x | x <- xs]
      In an equation for ‘encode’: encode n xs = [shift n x | x <- xs]
    • Relevant bindings include
        xs :: string (bound at src/Caesar.hs:17:10)
        encode :: Int -> string -> string (bound at src/Caesar.hs:17:1)
   |
17 | encode n xs = [ shift n x | x <- xs ]
   |               ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 19:08:24.254983574
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:31: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [ shift n x ¦ x <- xs ]
   |                               ^^
Failed, no modules loaded.
2022-07-14 19:09:34.778068513
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:31: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [ shift n x ¦ x <- xs ]
   |                               ^^
Failed, no modules loaded.
2022-07-14 19:10:03.205006018
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x < - xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:25: error: Variable not in scope: x :: Char
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                         ^

src/Caesar.hs:17:27: error:
    Variable not in scope: (¦) :: Char -> Bool -> a0
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                           ^

src/Caesar.hs:17:29: error: Variable not in scope: x
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                             ^
Failed, no modules loaded.
2022-07-14 19:10:21.637680602
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x  < - xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:25: error: Variable not in scope: x :: Char
   |
17 | encode n xs = [ shift n x ¦ x  < - xs ]
   |                         ^

src/Caesar.hs:17:27: error:
    Variable not in scope: (¦) :: Char -> Bool -> a0
   |
17 | encode n xs = [ shift n x ¦ x  < - xs ]
   |                           ^

src/Caesar.hs:17:29: error: Variable not in scope: x
   |
17 | encode n xs = [ shift n x ¦ x  < - xs ]
   |                             ^
Failed, no modules loaded.
2022-07-14 19:10:33.103745965
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x < - xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:25: error: Variable not in scope: x :: Char
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                         ^

src/Caesar.hs:17:27: error:
    Variable not in scope: (¦) :: Char -> Bool -> a0
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                           ^

src/Caesar.hs:17:29: error: Variable not in scope: x
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                             ^
Failed, no modules loaded.
2022-07-14 19:10:53.611288954
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦x < - xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:25: error: Variable not in scope: x :: Char
   |
17 | encode n xs = [ shift n x ¦x < - xs ]
   |                         ^

src/Caesar.hs:17:27: error:
    Variable not in scope: (¦) :: Char -> Bool -> a0
   |
17 | encode n xs = [ shift n x ¦x < - xs ]
   |                           ^

src/Caesar.hs:17:28: error: Variable not in scope: x
   |
17 | encode n xs = [ shift n x ¦x < - xs ]
   |                            ^
Failed, no modules loaded.
2022-07-14 19:11:03.758336431
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x < - xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:25: error: Variable not in scope: x :: Char
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                         ^

src/Caesar.hs:17:27: error:
    Variable not in scope: (¦) :: Char -> Bool -> a0
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                           ^

src/Caesar.hs:17:29: error: Variable not in scope: x
   |
17 | encode n xs = [ shift n x ¦ x < - xs ]
   |                             ^
Failed, no modules loaded.
2022-07-14 19:11:12.083307236
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (string -> string)
  17  encode n xs = [ shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:31: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [ shift n x ¦ x <- xs ]
   |                               ^^
Failed, no modules loaded.
2022-07-14 19:11:22.751539395
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:31: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [ shift n x ¦ x <- xs ]
   |                               ^^
Failed, no modules loaded.
2022-07-14 19:12:19.393766074
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:30: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [shift n x ¦ x <- xs ]
   |                              ^^
Failed, no modules loaded.
2022-07-14 19:12:50.713107238
>>> 
2022-07-14 19:12:52.2988937
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [shift n x ¦ x <-xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:30: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [shift n x ¦ x <-xs ]
   |                              ^^
Failed, no modules loaded.
2022-07-14 19:14:24.83280393
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:30: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [shift n x ¦ x <- xs ]
   |                              ^^
Failed, no modules loaded.
2022-07-14 19:14:30.5682618
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:30: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [shift n x ¦ x <- xs ]
   |                              ^^
Failed, no modules loaded.
2022-07-14 19:18:08.919163899
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x ¦ x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:31: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
   |
17 | encode n xs = [ shift n x ¦ x <- xs ]
   |                               ^^
Failed, no modules loaded.
2022-07-14 19:39:33.656004418
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 19:49:10.304528098
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 19:51:17.996912472
>>> it
"kdvnhoo lv ixq"
2022-07-14 19:52:41.88818364
>>> encode (-3) it
"haskell is fun"
2022-07-14 19:52:55.728084123
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24                  
  25  
  26  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 19:59:16.252999243
>>> length table 
26
2022-07-14 19:59:53.906209897
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Float
  26  percent n m = n / m * 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:1: error:
    • Couldn't match expected type ‘Float’
                  with actual type ‘Int -> Int’
    • The equation(s) for ‘percent’ have two value arguments,
        but its type ‘Int -> Float’ has only one
   |
26 | percent n m = n / m * 100
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 20:01:53.013814204
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 20:02:27.590744676
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n/m * 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n/m * 100
   |               ^^^^^^^^^
Failed, no modules loaded.
2022-07-14 20:03:15.73635643
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int - > Int -> Float
  26  percent n m = n / m * 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:25:16: error:
    Operator applied to too few arguments: -
   |
25 | percent :: Int - > Int -> Float
   |                ^
Failed, no modules loaded.
2022-07-14 20:04:09.216931526
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 20:05:43.613245541
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m )* 100
  27  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 20:08:11.88149791
>>> percent 5 15
33.333336
2022-07-14 20:08:25.20012109
>>> count 's' "Mississipi"

<interactive>:65:1: error:
    Variable not in scope: count :: Char -> t0 -> t
2022-07-14 20:14:44.090303006
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13    | isLower c = int2let ((let2int c + n) `mod` 26)
  14    | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.8
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m )* 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 20:14:49.641886037
>>> count 's' "Mississipi"
4
2022-07-14 20:15:06.736556273
>>> :q
Leaving GHCi.
